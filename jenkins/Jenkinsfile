pipeline {
    agent {
        docker {
            image 'bogdandragos/jenkins-k8s-libvirt-agent:latest'  // Use your custom image
            args '--user 0 -v /var/run/libvirt/libvirt-sock:/var/run/libvirt/libvirt-sock -v /run/libvirt:/run/libvirt -v /var/lib/libvirt/images:/var/lib/libvirt/images --privileged --network host'
            reuseNode true
        }
    }

    environment {
        LIBVIRT_URI = 'qemu:///system'
        ANSIBLE_INVENTORY = 'ansible/inventory.ini'  // Point to the rendered inventory file generated by Terraform
        KUBE_SSH_PUBLIC_KEY = credentials('kube-ssh-public-key')  // Fetch credential here
    }

    stages {
        stage('Prepare Base Image') {
            steps {
                timeout(time: 5, unit: 'MINUTES') {  // Prevent infinite download hangs
                    sh '''
                    echo "Starting base image preparation..."
                    BASE_IMAGE_PATH="/var/lib/libvirt/images/debian-bookworm-nocloud-base.qcow2"
                    BASE_IMAGE_URL="https://cloud.debian.org/images/cloud/bookworm/latest/debian-12-nocloud-amd64.qcow2"
                    if [ ! -f "$BASE_IMAGE_PATH" ]; then
                        echo "Downloading base image (401 MB) - this may take a minute..."
                        wget "$BASE_IMAGE_URL" -O "$BASE_IMAGE_PATH" --progress=dot:giga  # Show progress
                    else
                        echo "Base image already exists - skipping download."
                    fi
                    chmod 666 "$BASE_IMAGE_PATH"  # Make readable by all, including qemu process
                    chown 107:107 "$BASE_IMAGE_PATH" || true  # Align with libvirt-qemu UID/GID (adjust if needed)
                    echo "Base image preparation complete."
                    '''
                }
            }
        }

        stage('Setup Libvirt Pool') {
            steps {
                sh '''
                # Ensure the default storage pool exists and is active
                virsh pool-define-as default dir --target /var/lib/libvirt/images || true
                virsh pool-start default || true
                virsh pool-autostart default || true
                '''
            }
        }

        stage('Setup SSH Known Hosts') {
            steps {
                sh '''
                mkdir -p ~/.ssh
                ssh-keyscan -H github.com >> ~/.ssh/known_hosts
                chmod 600 ~/.ssh/known_hosts
                '''
            }
        }

        stage('Checkout') {
            steps {
                git url: 'git@github.com:bogdandragosvasile/k8s-libvirt-cluster.git', branch: 'master', credentialsId: 'github-ssh-key'
            }
        }

        stage('Terraform Init') {
            steps {
                dir('terraform') {
                    sh 'terraform init'
                }
            }
        }

        stage('Terraform Plan') {
            steps {
                dir('terraform') {
                    sh 'terraform plan -var="kube_ssh_public_key=${KUBE_SSH_PUBLIC_KEY}" -out=plan.tfout'
                }
            }
        }

        stage('Terraform Apply') {
            steps {
                dir('terraform') {
                    sh 'terraform apply -auto-approve plan.tfout'
                }
            }
        }

        stage('Wait for VMs to be Reachable') {
            steps {
                sh '''
                MAX_RETRIES=30
                SLEEP_TIME=10
                for host in $(jq -r '.vm_ips.value[]' terraform/outputs.json); do
                    for i in $(seq 1 $MAX_RETRIES); do
                        if nc -zv $host 22; then
                            echo "$host is reachable on port 22."
                            break
                        fi
                        echo "Waiting for $host to be reachable... ($i/$MAX_RETRIES)"
                        sleep $SLEEP_TIME
                    done
                    if [ $i -eq $MAX_RETRIES ]; then
                        echo "Failed to reach $host after $MAX_RETRIES attempts."
                        exit 1
                    fi
                done
                '''
            }
        }

        stage('Generate Ansible Inventory') {
            steps {
                sh '''
                echo "Generating vars.yaml from Terraform outputs..."
                cd terraform
                terraform output -json > ../ansible/outputs.json  # Capture all outputs as JSON
                # Convert JSON to valid YAML format (add --- header)
                echo "---" > ../ansible/vars.yaml
                jq -r 'to_entries | map("\\(.key): \\(.value.value)") | join("\\n")' ../ansible/outputs.json >> ../ansible/vars.yaml
                echo "vars.yaml contents:"
                cat ../ansible/vars.yaml  # Debug
                echo "Inventory file check:"
                ls -l ../ansible/inventory.ini  # Ensure it exists (generated by Terraform)
                '''
            }
        }

        stage('Ansible Setup') {
            steps {
                dir('ansible') {
                    sh '''
                    echo "Running Ansible with inventory: ${ANSIBLE_INVENTORY}"
                    ansible-playbook -i ${ANSIBLE_INVENTORY} 01-initial.yaml --extra-vars "@vars.yaml"
                    ansible-playbook -i ${ANSIBLE_INVENTORY} 02-packages.yaml --extra-vars "@vars.yaml"
                    ansible-playbook -i ${ANSIBLE_INVENTORY} 03-lb.yaml --extra-vars "@vars.yaml"
                    ansible-playbook -i ${ANSIBLE_INVENTORY} 04-k8s.yaml --extra-vars "@vars.yaml"
                    ansible-playbook -i ${ANSIBLE_INVENTORY} 05-control-plane.yaml --extra-vars "@vars.yaml"
                    ansible-playbook -i ${ANSIBLE_INVENTORY} 06-worker.yaml --extra-vars "@vars.yaml"
                    ansible-playbook -i ${ANSIBLE_INVENTORY} 07-k8s-config.yaml --extra-vars "@vars.yaml"
                    '''
                }
            }
        }

        stage('Verify Cluster') {
            steps {
                echo 'Cluster setup complete. Verify with kubectl get nodes or similar.'
            }
        }
    }

    post {
        always {
            echo 'Pipeline completed.'
        }
        failure {
            node('') {  // Ensure a node context for cleanup
                sh './libvirt-clean.sh || true'  // Run cleanup, ignore if script not found
            }
        }
    }
}
