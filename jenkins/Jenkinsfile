pipeline {
  agent {
    docker {
      image 'bogdandragos/jenkins-k8s-libvirt-agent:latest'
      args """
        --user 0
        --privileged
        --network host
        -v /var/run/libvirt/libvirt-sock:/var/run/libvirt/libvirt-sock
        -v /run/libvirt:/run/libvirt
        -v /var/lib/libvirt/images:/var/lib/libvirt/images
        -v /root/.ssh:/root/.ssh:ro
      """
      reuseNode true
    }
  }

  options {
    ansiColor('xterm')
    timestamps()
    timeout(time: 60, unit: 'MINUTES')
    buildDiscarder(logRotator(numToKeepStr: '20'))
  }

  environment {
    LIBVIRT_URI         = 'qemu:///system'
    ANSIBLE_INVENTORY   = 'inventory.ini'
    KUBE_SSH_PUBLIC_KEY = credentials('kube-ssh-public-key')
  }

  stages {
    stage('Prepare Base Image') {
      steps {
        sh '''
          echo "\\033[36m[Prepare Base Image]\\033[0m"
          BASE_IMAGE_PATH="/var/lib/libvirt/images/ubuntu-24.04-server-cloudimg-amd64.img"
          BASE_IMAGE_URL="https://cloud-images.ubuntu.com/noble/current/noble-server-cloudimg-amd64.img"
          if [ ! -f "$BASE_IMAGE_PATH" ]; then
            echo "Downloading base image..."
            wget "$BASE_IMAGE_URL" -O "$BASE_IMAGE_PATH" --progress=dot:giga
          else
            echo "Base image already exists - skipping download."
          fi
          chmod 666 "$BASE_IMAGE_PATH" || true
          chown 107:107 "$BASE_IMAGE_PATH" || true
        '''
      }
    }

    stage('Setup Libvirt Pool') {
      steps {
        sh '''
          echo "\\033[36m[Setup Libvirt Pool]\\033[0m"
          virsh pool-define-as default dir --target /var/lib/libvirt/images || true
          virsh pool-start default || true
          virsh pool-autostart default || true
        '''
      }
    }

    stage('Checkout Code') {
      steps {
        git url: 'git@github.com:bogdandragosvasile/k8s-libvirt-cluster.git',
            branch: 'master',
            credentialsId: 'github-ssh-key'
      }
    }

    stage('Terraform Init') {
      steps {
        dir('terraform') {
          sh 'terraform init'
        }
      }
    }

    stage('Terraform Plan') {
      steps {
        dir('terraform') {
          sh '''
            terraform plan \\
              -var="kube_ssh_public_key=${KUBE_SSH_PUBLIC_KEY}" \\
              -out=plan.tfout
          '''
        }
      }
    }

    stage('Terraform Apply') {
      steps {
        dir('terraform') {
          sh 'terraform apply -auto-approve plan.tfout'
        }
      }
    }

    stage('Generate Ansible Inventory') {
      steps {
        dir('terraform') {
          sh 'terraform output -json > outputs.json && cat outputs.json'
        }
        sh '''
          echo "\\033[36m[Preserve original vars.yaml and append Terraform outputs]\\033[0m"
          
          # Show original vars.yaml
          echo "Original vars.yaml:"
          cat ansible/vars.yaml
          
          # Append Terraform outputs to existing vars.yaml (don't overwrite!)
          echo "" >> ansible/vars.yaml
          echo "# Terraform VM outputs:" >> ansible/vars.yaml
          jq -r 'to_entries | map("\\(.key): \\(.value.value)") | join("\\n")' terraform/outputs.json >> ansible/vars.yaml
          
          echo "\\033[36m[Final vars.yaml with Terraform outputs:]\\033[0m"
          cat ansible/vars.yaml
          
          echo "\\033[36m[Check inventory.ini]\\033[0m"
          ls -l ansible/inventory.ini
          cat ansible/inventory.ini
        '''
      }
    }

    stage('Wait for VMs to be Reachable via SSH') {
      steps {
        sh '''
          echo "\\033[36m[Wait for VMs over SSH]\\033[0m"
          MAX_RETRIES=60
          SLEEP_TIME=10
          cd terraform

          for host in $(jq -r '.vm_ips.value | to_entries | map(.value) | .[]' outputs.json); do
            echo "Checking SSH access on $host..."
            for i in $(seq 1 $MAX_RETRIES); do
              if ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null \\
                -i /root/.ssh/id_ed25519 -o ConnectTimeout=3 ubuntu@$host 'true' 2>/dev/null; then
                echo "OK: $host reachable via SSH"
                break
              fi
              echo "Waiting for $host... ($i/$MAX_RETRIES)"
              sleep $SLEEP_TIME
            done
            if [ $i -eq $MAX_RETRIES ]; then
              echo "\\033[31mERROR: $host not reachable via SSH\\033[0m"
              exit 1
            fi
          done
        '''
      }
    }

    stage('Run Ansible Playbook') {
      steps {
        dir('ansible') {
          sh '''
            echo "\\033[36m[Ansible Setup]\\033[0m"
            ANSIBLE_HOST_KEY_CHECKING=False \\
            ansible-playbook -i ${ANSIBLE_INVENTORY} main.yaml --extra-vars "@vars.yaml" -vv
          '''
        }
      }
    }

    stage('Verify Cluster') {
      steps {
        echo 'Cluster setup complete â€” verify with kubectl once kubeconfig is available.'
      }
    }
  }

  post {
    always {
      echo 'Pipeline completed.'
    }
    failure {
      sh '''
        echo "\\033[33m[Cleanup on Failure]\\033[0m"
        if [ -x ./scripts/cleanup_vms.sh ]; then
          ./scripts/cleanup_vms.sh || true
        fi
      '''
    }
  }
}
