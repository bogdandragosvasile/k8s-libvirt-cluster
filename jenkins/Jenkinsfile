pipeline {
    agent {
        docker {
            image 'bogdandragos/jenkins-k8s-libvirt-agent:latest'  // Use your custom image
            args '--user 0 -v /var/run/libvirt/libvirt-sock:/var/run/libvirt/libvirt-sock -v /run/libvirt:/run/libvirt -v /var/lib/libvirt/images:/var/lib/libvirt/images --privileged --network host'
            reuseNode true
        }
    }

    environment {
        LIBVIRT_URI = 'qemu:///system'
        ANSIBLE_INVENTORY = 'inventory.ini'  // Relative to ansible dir
        KUBE_SSH_PUBLIC_KEY = credentials('kube-ssh-public-key')  // Fetch credential here
    }

    stages {
        stage('Prepare Base Image') {
            steps {
                timeout(time: 5, unit: 'MINUTES') {  // Prevent infinite download hangs
                    sh '''
                    echo "Starting base image preparation..."
                    BASE_IMAGE_PATH="/var/lib/libvirt/images/ubuntu-24.04-server-cloudimg-amd64.img"
                    BASE_IMAGE_URL="https://cloud-images.ubuntu.com/noble/current/noble-server-cloudimg-amd64.img"
                    if [ ! -f "$BASE_IMAGE_PATH" ]; then
                        echo "Downloading base image (~500 MB) - this may take a minute..."
                        wget "$BASE_IMAGE_URL" -O "$BASE_IMAGE_PATH" --progress=dot:giga  # Show progress
                    else
                        echo "Base image already exists - skipping download."
                    fi
                    chmod 666 "$BASE_IMAGE_PATH"  # Make readable by all, including qemu process
                    chown 107:107 "$BASE_IMAGE_PATH" || true  # Align with libvirt-qemu UID/GID (adjust if needed)
                    echo "Base image preparation complete."
                    '''
                }
            }
        }

        stage('Setup Libvirt Pool') {
            steps {
                sh '''
                # Ensure the default storage pool exists and is active
                virsh pool-define-as default dir --target /var/lib/libvirt/images || true
                virsh pool-start default || true
                virsh pool-autostart default || true
                '''
            }
        }

        stage('Setup SSH Known Hosts') {
            steps {
                sh '''
                mkdir -p ~/.ssh
                ssh-keyscan -H github.com >> ~/.ssh/known_hosts
                chmod 600 ~/.ssh/known_hosts
                '''
            }
        }

        stage('Checkout') {
            steps {
                git url: 'git@github.com:bogdandragosvasile/k8s-libvirt-cluster.git', branch: 'master', credentialsId: 'github-ssh-key'
            }
        }

        stage('Terraform Init') {
            steps {
                dir('terraform') {
                    sh 'terraform init'
                }
            }
        }

        stage('Terraform Plan') {
            steps {
                dir('terraform') {
                    sh 'terraform plan -var="kube_ssh_public_key=${KUBE_SSH_PUBLIC_KEY}" -out=plan.tfout'
                }
            }
        }

        stage('Terraform Apply') {
            steps {
                dir('terraform') {
                    sh 'terraform apply -auto-approve plan.tfout'
                }
            }
        }

        stage('Generate Ansible Inventory') {
            steps {
                dir('terraform') {
                    sh '''
                    echo "Generating outputs.json from Terraform outputs..."
                    terraform output -json > outputs.json
                    echo "outputs.json contents:"
                    cat outputs.json  # Debug
                    '''
                }
                sh '''
                echo "Generating vars.yaml from outputs.json..."
                # Convert JSON to valid YAML format (add --- header)
                echo "---" > ansible/vars.yaml
                jq -r 'to_entries | map("\\(.key): \\(.value.value)") | join("\\n")' terraform/outputs.json >> ansible/vars.yaml
                echo "vars.yaml contents:"
                cat ansible/vars.yaml  # Debug
                echo "Inventory file check:"
                ls -l ansible/inventory.ini  # Ensure it exists (generated by Terraform)
                '''
            }
        }

        stage('Wait for VMs to be Reachable') {
            steps {
                sh '''
                MAX_RETRIES=90  # 15 minutes for boot/SSH startup
                SLEEP_TIME=10
                cd terraform  # Change to terraform dir for outputs.json
                for host in $(jq -r '.vm_ips.value[]' outputs.json); do
                    echo "Checking reachability for $host..."
                    for i in $(seq 1 $MAX_RETRIES); do
                        if ping -c 1 $host > /dev/null 2>&1 && nc -zv $host 22; then
                            echo "$host is reachable on port 22."
                            break
                        fi
                        echo "Waiting for $host to be reachable... ($i/$MAX_RETRIES)"
                        sleep $SLEEP_TIME
                    done
                    if [ $i -eq $MAX_RETRIES ]; then
                        echo "Failed to reach $host after $MAX_RETRIES attempts."
                        exit 1
                    fi
                done
                '''
            }
        }

        stage('Ansible Setup') {
            steps {
                dir('ansible') {
                    sh '''
                    echo "Running main Ansible playbook with inventory: ${ANSIBLE_INVENTORY}"
                    ansible-playbook -i ${ANSIBLE_INVENTORY} main.yaml --extra-vars "@vars.yaml" -vvv  # Verbose for debugging
                    '''
                }
            }
        }

        stage('Verify Cluster') {
            steps {
                echo 'Cluster setup complete. Verify with kubectl get nodes or similar.'
            }
        }
    }

    post {
        always {
            echo 'Pipeline completed.'
        }
        failure {
            node('') {  // Ensure a node context for cleanup
                sh './libvirt-clean.sh || true'  // Run cleanup, ignore if script not found
            }
        }
    }
}
